name: Functionality test for helm chart
run-name: ${{ github.actor }} is testing out helm chart functions üöÄ

concurrency:
  group: ${{ github.ref }}
  cancel-in-progress: true

on:
  push:
    branches:
      - main
    paths:
      - ".github/**"
      - "**/*.py"
      - "pyproject.toml"
      - "helm/**"
  pull_request:
    paths:
      - ".github/**"
      - "**/*.py"
      - "pyproject.toml"
      - "helm/**"

jobs:
  e2e-k8s-functionality-test:
    name: E2E Kubernetes Functionality Test
    runs-on: self-hosted
    timeout-minutes: 20
    steps:
      - name: Check out repository code
        uses: actions/checkout@v4
      - name: Verify K8s cluster is ready
        run: |
          kubectl config use-context minikube
          printf "\n=== Cluster Details ===\n"
          kubectl config view
          kubectl cluster-info
          kubectl get nodes -o wide
          kubectl describe nodes
          kubectl get pods -A -o wide
          kubectl get events --sort-by='.lastTimestamp' -A
          helm version
          kubectl version
          printf "\n=== Final Cluster Health Check ===\n"
          kubectl get cs
          kubectl -n kube-system wait --for=condition=Ready pod --all --timeout=300s

      - name: Clean up Docker system before building image
        run: |
          echo "Cleaning up git-act-router Docker system..."
          # Remove only git-act-router related images
          docker images --filter=reference='git-act-router*' -q | xargs -r docker rmi -f
          # Clean up dangling images
          docker image prune --force

      - name: Build and Load Docker image
        env:
          DOCKER_IMAGE_NAME: localhost:5000/git-act-router
        run: |
          sudo docker build --build-arg INSTALL_OPTIONAL_DEP=default \
            --no-cache \
            -t "$DOCKER_IMAGE_NAME" \
            -f docker/Dockerfile .
          echo "‚úÖ Docker image $DOCKER_IMAGE_NAME built successfully!"
          echo "Verifying Docker image..."
          if ! docker images "$DOCKER_IMAGE_NAME" | grep "$DOCKER_IMAGE_NAME"; then
            echo "‚ùå Docker image $DOCKER_IMAGE_NAME not found after build!"
            exit 1
          fi
          echo "‚úÖ Docker image $DOCKER_IMAGE_NAME found after build!"
          sudo sysctl fs.protected_regular=0
          # Verify image integrity before loading
          echo "Verifying image digest..."
          if ! docker inspect --format='{{.Id}}' "$DOCKER_IMAGE_NAME" >/dev/null 2>&1; then
            echo "‚ùå Failed to verify image digest for $DOCKER_IMAGE_NAME"
            exit 1
          fi
          # Directly load Docker image to K8s cluster
          echo "Loading Docker image into K8s cluster..."
          sudo docker push localhost:5000/git-act-router


      - name: Run Helm tests with matrix strategy
        env:
          DOCKER_BUILDKIT: 1
        run: |
          set -e
          TEST_SCENARIOS=(
            ".github/router.yaml routerSpec"
          )

          for SCENARIO in "${TEST_SCENARIOS[@]}"; do
            VALUES_FILE="$(echo "$SCENARIO" | cut -d' ' -f1)"
            echo "üöÄ Deploying scenario with values file: ${VALUES_FILE}"
            helm uninstall vllm || true
            helm lint ./helm || {
              echo "‚ùå Helm lint failed"
              exit 1
            }
            helm install vllm ./helm -f "$VALUES_FILE" --debug || {
              echo "‚ùå Helm install failed"
              kubectl get pods -A
              kubectl describe pod -l environment=router,release=router --namespace=default
              kubectl get events --sort-by='.lastTimestamp'
              exit 1
            }

            echo "‚è≥ Waiting for pods to be ready..."
            RETRIES=5
            kubectl config use-context minikube
            for i in $(seq 1 "${RETRIES}"); do
              if kubectl wait --for=condition=ready pod -l environment=router,release=router --namespace=default --timeout=60s; then
                echo "‚úÖ Pods are ready after ${i} attempt(s)"
                kubectl describe pods -n default -l environment=router,release=router
                break
              else
                echo "üö® Attempt ${i}/${RETRIES}: Pods failed to become ready"
                kubectl describe pod -l environment=router,release=router --namespace=default
                kubectl get events --sort-by='.lastTimestamp'
                kubectl logs -l environment=router,release=router --namespace=default --all-containers=true
                if [ "${i}" -eq "${RETRIES}" ]; then
                  echo "‚ùå Pods did not become ready after ${RETRIES} attempts."
                  kubectl logs -l environment=router,release=router --namespace=default --all-containers=true
                  exit 1
                fi
                echo "üîÑ Retrying in 10 seconds..."
                sleep 10
              fi
            done
          done

      - name: Validate the installation of vllm backend pod
        run: |
          set -e
          kubectl config use-context minikube
          while true; do
          # Check each vllm pod individually
          kubectl get pods --no-headers | grep "vllm" | while read -r line; do
              pod_name=$(echo "$line" | awk '{print $1}')
              status=$(echo "$line" | awk '{print $3}')
              ready=$(echo "$line" | awk '{print $2}')

              # Log timestamp and pod info
              timestamp=$(date '+%Y-%m-%d %H:%M:%S')
              echo "[$timestamp] Checking pod: $pod_name"

              if [[ "$status" != "Running" ]] || [[ "$ready" != "1/1" ]]; then
                  # Save detailed pod events
                  echo "[$timestamp] Pod $pod_name not ready (Status: $status, Ready: $ready)"
                  kubectl describe pod "$pod_name"
                  kubectl logs "$pod_name" -p
              fi
          done

          # Check if all pods are ready
          ready_count=$(kubectl get pods --no-headers | grep "vllm" | grep "Running" | grep "1/1" | wc -l)
          total_pods=$(kubectl get pods --no-headers | grep "vllm" | wc -l)

          if [[ $ready_count -eq $total_pods ]]; then
              echo "All $total_pods llmstack pods are now Ready and in Running state."
              break
          fi

          echo "Not all pods are ready yet. Checking again in 20 seconds..."
          sleep 20
          done
        timeout-minutes: 10
      - name: Curl the router to verify the functionality
        run: |
          set -ex
          kubectl config use-context minikube
          kubectl patch service vllm-router-service -p '{"spec":{"type":"NodePort"}}'
          ip=$(minikube ip)
          port=$(kubectl get svc vllm-router-service -o=jsonpath='{.spec.ports[0].nodePort}')

          for i in {1..3}; do
            if curl_output=$(curl -v -H "Content-Type: application/json" -X GET http://"$ip":"$port"/v1/models | jq .); then
              break
            else
              echo "‚ö†Ô∏è Retry $i/3..."
              sleep 5
            fi
          done

          if [[ -z "$curl_output" ]]; then
              echo "[Error] Empty response from curl"
              kubectl get pods -o wide
              kubectl describe endpoints vllm-router-service
              exit 1
          fi

          echo "‚úÖ Successfully requested: $curl_output"
      - name: Clean up resources
        run: |
          set -e
          echo "Cleaning up resources for production stack..."
          helm uninstall vllm || true
